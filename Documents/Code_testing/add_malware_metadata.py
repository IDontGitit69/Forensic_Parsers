#!/usr/bin/env python3
"""
YARA Rule Malware Name Metadata Injector

This script reads YARA rule bundles downloaded from Mandiant Advantage,
extracts the malware name from the filename, and adds a 'malware_name'
field to the meta section of each rule in the bundle.
"""

import argparse
import os
import re
import sys
from pathlib import Path


def parse_yara_file(content):
    """
    Parse a YARA file and return a list of rule dictionaries.
    Each dictionary contains the rule's full text and position information.
    """
    # Pattern to match YARA rules (including imports and includes before rules)
    # This captures everything from 'rule' keyword to the closing brace
    rule_pattern = re.compile(
        r'(rule\s+\w+\s*(?:\:\s*[\w\s]+)?\s*\{.*?\n\})',
        re.DOTALL | re.MULTILINE
    )
    
    rules = []
    for match in rule_pattern.finditer(content):
        rule_text = match.group(1)
        rules.append({
            'text': rule_text,
            'start': match.start(),
            'end': match.end()
        })
    
    return rules


def extract_rule_name(rule_text):
    """Extract the rule name from a YARA rule."""
    match = re.search(r'rule\s+(\w+)', rule_text)
    return match.group(1) if match else None


def add_malware_name_to_meta(rule_text, malware_name):
    """
    Add malware_name field to the meta section of a YARA rule.
    If no meta section exists, create one.
    """
    # Check if meta section exists
    meta_pattern = re.compile(r'(\s*meta\s*:\s*\n)', re.MULTILINE)
    meta_match = meta_pattern.search(rule_text)
    
    if meta_match:
        # Meta section exists, add malware_name as the first field
        meta_pos = meta_match.end()
        # Determine indentation from the next line if possible
        remaining = rule_text[meta_pos:]
        indent_match = re.match(r'^(\s+)', remaining)
        indent = indent_match.group(1) if indent_match else '        '
        
        new_field = f'{indent}malware_name = "{malware_name}"\n'
        modified_rule = rule_text[:meta_pos] + new_field + rule_text[meta_pos:]
    else:
        # No meta section, create one after the rule declaration
        # Find the opening brace of the rule
        brace_pattern = re.compile(r'(rule\s+\w+\s*(?:\:\s*[\w\s]+)?\s*\{\s*\n)')
        brace_match = brace_pattern.search(rule_text)
        
        if brace_match:
            insert_pos = brace_match.end()
            meta_section = f'    meta:\n        malware_name = "{malware_name}"\n\n'
            modified_rule = rule_text[:insert_pos] + meta_section + rule_text[insert_pos:]
        else:
            # Fallback: couldn't parse rule structure, return original
            print(f"Warning: Could not parse rule structure, skipping malware_name injection")
            return rule_text
    
    return modified_rule


def process_yara_file(input_path, output_path, malware_name):
    """
    Process a single YARA file: parse rules, add malware_name metadata,
    and write to output file.
    """
    try:
        with open(input_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except Exception as e:
        print(f"Error reading {input_path}: {e}")
        return False
    
    # Extract any header content (imports, includes, comments) before the first rule
    first_rule_match = re.search(r'rule\s+\w+', content)
    if first_rule_match:
        header = content[:first_rule_match.start()]
        rules_content = content[first_rule_match.start():]
    else:
        header = ""
        rules_content = content
    
    # Parse all rules in the file
    rules = parse_yara_file(rules_content)
    
    if not rules:
        print(f"Warning: No rules found in {input_path}")
        return False
    
    # Process each rule
    modified_rules = []
    for rule_info in rules:
        rule_name = extract_rule_name(rule_info['text'])
        modified_rule = add_malware_name_to_meta(rule_info['text'], malware_name)
        modified_rules.append(modified_rule)
        print(f"  - Processed rule: {rule_name}")
    
    # Reconstruct the file with header + modified rules
    output_content = header + '\n'.join(modified_rules)
    
    # Write to output file
    try:
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(output_content)
        return True
    except Exception as e:
        print(f"Error writing {output_path}: {e}")
        return False


def main():
    parser = argparse.ArgumentParser(
        description='Add malware_name metadata to YARA rules based on filename',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Example:
  python add_malware_metadata.py --input-dir ./raw_rules --output-dir ./processed_rules

This will process all .yar files in ./raw_rules and save modified versions to ./processed_rules
        """
    )
    
    parser.add_argument(
        '--input-dir',
        required=True,
        help='Directory containing YARA rule files (.yar)'
    )
    
    parser.add_argument(
        '--output-dir',
        required=True,
        help='Directory to save processed YARA rule files'
    )
    
    args = parser.parse_args()
    
    input_dir = Path(args.input_dir)
    output_dir = Path(args.output_dir)
    
    # Validate input directory
    if not input_dir.exists():
        print(f"Error: Input directory does not exist: {input_dir}")
        sys.exit(1)
    
    if not input_dir.is_dir():
        print(f"Error: Input path is not a directory: {input_dir}")
        sys.exit(1)
    
    # Create output directory if it doesn't exist
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Find all .yar files
    yar_files = list(input_dir.glob('*.yar'))
    
    if not yar_files:
        print(f"Warning: No .yar files found in {input_dir}")
        sys.exit(0)
    
    print(f"Found {len(yar_files)} YARA rule files to process\n")
    
    # Process each file
    success_count = 0
    for yar_file in yar_files:
        # Extract malware name from filename (remove .yar extension)
        malware_name = yar_file.stem
        
        output_file = output_dir / yar_file.name
        
        print(f"Processing: {yar_file.name} (malware_name: {malware_name})")
        
        if process_yara_file(yar_file, output_file, malware_name):
            success_count += 1
            print(f"  ✓ Saved to: {output_file}\n")
        else:
            print(f"  ✗ Failed to process {yar_file.name}\n")
    
    print(f"\nCompleted: {success_count}/{len(yar_files)} files processed successfully")


if __name__ == '__main__':
    main()
