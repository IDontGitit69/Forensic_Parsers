# GitLab CI/CD Pipeline for YARA Rule Validation and Deployment

stages:
  - validate
  - push
  - integrate  # NEW STAGE

variables:
  # Directories
  NEW_RULES_DIR: "Yara Rules/New Rules"
  VALIDATED_DIR: "Yara Rules/validated"
  FAILED_DIR: "Yara Rules/failed"
  BASELINE_DIR: "Yara Rules/Baseline_Rules"  # NEW
  DATABASE_PATH: "Yara Rules/database/yara_rules.db"  # NEW
  GIT_DEPTH: 0
  
  # Report files
  JSON_REPORT: "Yara Rules/validation_report.json"
  MD_REPORT: "Yara Rules/validation_report.md"
 
  # Python image
  PYTHON_IMAGE: "python:3.11-slim"
 
# Template for Python setup
.python_setup: &python_setup
  before_script:
    - pip3 install --quiet --no-cache-dir yara-python
    - python3 --version
    - python3 -c "import yara; print(f'YARA version: {yara.__version__}')"
 
# ==============================================================================
# STAGE 1: VALIDATE
# ==============================================================================
validate_yara_rules:
  stage: validate
  rules:
    - changes:
        - "$NEW_RULES_DIR/**"
      when: on_success
    - when: never
  image: $PYTHON_IMAGE
  <<: *python_setup
  script:
    - echo "üîç Validating YARA rules in $NEW_RULES_DIR"
    - echo "üßπ Clearing previous failed rules"
    - rm -rf "$FAILED_DIR"
    - mkdir -p "$FAILED_DIR"
    - |
      python3 "Yara Rules/Tools/Yaralyzer.py" "$NEW_RULES_DIR" \
        --output-valid-dir "$VALIDATED_DIR" \
        --output-failed-dir "$FAILED_DIR" \
        --json-report "$JSON_REPORT" \
        --markdown-report "$MD_REPORT" \
        --deduplicate \
        --verbose \
        --require-metadata \
        --baseline-db "$DATABASE_PATH"
    - VALIDATION_EXIT_CODE=$?
    - echo "Validation exit code=$VALIDATION_EXIT_CODE"
    - echo "üßπ Cleaning up processed files from $NEW_RULES_DIR"
    - |
      FILES_BEFORE=$(find "$NEW_RULES_DIR" -type f \( -name "*.yar" -o -name "*.yara" -o -name "*.rule" \) | wc -l)
      echo "üìä Files in $NEW_RULES_DIR before cleanup: $FILES_BEFORE"
    - |
      PROCESSED_FILES=""
      if [ -d "$VALIDATED_DIR" ] && [ -n "$(ls -A "$VALIDATED_DIR" 2>/dev/null)" ]; then
        echo "‚úÖ Found validated files:"
        for file in "$VALIDATED_DIR"/*; do
          [ -f "$file" ] || continue
          basename_file=$(basename "$file")
          original_name=$(grep "^// Source:" "$file" 2>/dev/null | sed 's/.*\///' || echo "$basename_file")
          if [ -z "$original_name" ]; then
            original_name="$basename_file"
          fi
          echo "  - $original_name"
          PROCESSED_FILES="$PROCESSED_FILES $original_name"
        done
      fi
    - |
      if [ -d "$FAILED_DIR" ] && [ -n "$(ls -A "$FAILED_DIR" 2>/dev/null)" ]; then
        echo "‚ùå Found failed files:"
        for file in "$FAILED_DIR"/*; do
          [ -f "$file" ] || continue
          basename_file=$(basename "$file")
          original_name=$(grep "^// Source:" "$file" 2>/dev/null | sed 's/.*\///' || echo "$basename_file")
          if [ -z "$original_name" ]; then
            original_name="$basename_file"
          fi
          echo "  - $original_name"
          PROCESSED_FILES="$PROCESSED_FILES $original_name"
        done
      fi
    - PROCESSED_FILES=$(echo "$PROCESSED_FILES" | tr ' ' '\n' | sort -u | tr '\n' ' ')
    - |
      if [ -n "$PROCESSED_FILES" ]; then
        echo "üóëÔ∏è  Removing processed files from $NEW_RULES_DIR:"
        for filename in $PROCESSED_FILES; do
          filepath="$NEW_RULES_DIR/$filename"
          if [ -f "$filepath" ]; then
            echo "  - Removing: $filename"
            rm -f "$filepath"
          fi
        done
      else
        echo "‚ö†Ô∏è  No processed files identified for cleanup"
      fi
    - echo "üóëÔ∏è  Removing all YARA files from $NEW_RULES_DIR:"
    - find "$NEW_RULES_DIR" -type f \( -name "*.yar" -o -name "*.yara" -o -name "*.rule" \) -delete
    - |
      FILES_AFTER=$(find "$NEW_RULES_DIR" -type f \( -name "*.yar" -o -name "*.yara" -o -name "*.rule" \) | wc -l)
      echo "üìä Files in $NEW_RULES_DIR after cleanup: $FILES_AFTER"
      echo "üìä Files removed: $((FILES_BEFORE - FILES_AFTER))"
    - echo "üìä Remaining files in $NEW_RULES_DIR:"
    - ls -la "$NEW_RULES_DIR" || echo "Directory empty or not found"
    - exit $VALIDATION_EXIT_CODE
 
  artifacts:
    when: always
    paths:
      - $VALIDATED_DIR/
      - $FAILED_DIR/
      - $JSON_REPORT
      - $MD_REPORT
    expire_in: 7 days
 
  allow_failure: true
 
# ==============================================================================
# STAGE 2: PUSH
# ==============================================================================
push_to_repo:
  stage: push
  needs:
    - job: validate_yara_rules
      artifacts: true
  rules:
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - "$NEW_RULES_DIR/**"
      when: on_success
  script:
    - echo "üì§ Pushing validation results to repository"
    
    # Verify we have artifacts to push
    - |
      FILES_TO_PUSH=0
      [ -f "$JSON_REPORT" ] && FILES_TO_PUSH=$((FILES_TO_PUSH + 1))
      [ -f "$MD_REPORT" ] && FILES_TO_PUSH=$((FILES_TO_PUSH + 1))
      [ -d "$VALIDATED_DIR" ] && [ -n "$(ls -A "$VALIDATED_DIR" 2>/dev/null)" ] && FILES_TO_PUSH=$((FILES_TO_PUSH + 1))
      
      if [ $FILES_TO_PUSH -eq 0 ]; then
        echo "‚ö†Ô∏è  No files to push (validation may have failed or produced no output)"
        exit 0
      fi
      
      echo "‚úÖ Found $FILES_TO_PUSH artifact(s) to push"
    
    # Configure Git
    - git config --global user.email "${user_email}"
    - git config --global user.name "${user_name}"
    - git config --global http.sslcainfo "${SSL_CERT_FILE_PATH}"
    - git remote set-url origin https://alesher:${PAT_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
    
    # Pull latest changes to avoid conflicts
    - git pull origin $CI_COMMIT_REF_NAME --rebase || true
    
    # Remove processed files from NEW_RULES_DIR and stage deletions
    - echo "üóëÔ∏è Removing processed files from $NEW_RULES_DIR"
    - |
      REMOVED_COUNT=0
      
      # Remove validated files from NEW_RULES_DIR
      if [ -d "$VALIDATED_DIR" ] && [ -n "$(ls -A "$VALIDATED_DIR" 2>/dev/null)" ]; then
        echo "‚úÖ Processing validated files..."
        for file in "$VALIDATED_DIR"/*; do
          [ -f "$file" ] || continue
          
          # Extract the original source filename from the header comment
          original_name=$(grep "^// Source:" "$file" 2>/dev/null | sed 's/^.*\///' | head -1)
          
          # If we can't find it in the header, fall back to the basename (strip _N suffixes)
          if [ -z "$original_name" ]; then
            basename_file=$(basename "$file")
            # Remove _1, _2, _3, etc. suffixes before extension
            original_name=$(echo "$basename_file" | sed 's/_[0-9]\+\(\.[^.]*\)$/\1/')
          fi
          
          source_file="$NEW_RULES_DIR/$original_name"
          
          if [ -f "$source_file" ]; then
            echo "  üóëÔ∏è  Removing validated: $original_name"
            git rm -f "$source_file" 2>/dev/null || rm -f "$source_file"
            REMOVED_COUNT=$((REMOVED_COUNT + 1))
          fi
        done
      fi
      
      # Remove failed files from NEW_RULES_DIR
      if [ -d "$FAILED_DIR" ] && [ -n "$(ls -A "$FAILED_DIR" 2>/dev/null)" ]; then
        echo "‚ùå Processing failed files..."
        for file in "$FAILED_DIR"/*; do
          [ -f "$file" ] || continue
          
          # Extract the original source filename from the header comment
          original_name=$(grep "^// Source:" "$file" 2>/dev/null | sed 's/^.*\///' | head -1)
          
          # If we can't find it in the header, fall back to the basename (strip _N suffixes)
          if [ -z "$original_name" ]; then
            basename_file=$(basename "$file")
            # Remove _1, _2, _3, etc. suffixes before extension
            original_name=$(echo "$basename_file" | sed 's/_[0-9]\+\(\.[^.]*\)$/\1/')
          fi
          
          source_file="$NEW_RULES_DIR/$original_name"
          
          if [ -f "$source_file" ]; then
            echo "  üóëÔ∏è  Removing failed: $original_name"
            git rm -f "$source_file" 2>/dev/null || rm -f "$source_file"
            REMOVED_COUNT=$((REMOVED_COUNT + 1))
          fi
        done
      fi
      
      echo "üìä Total files removed from $NEW_RULES_DIR: $REMOVED_COUNT"
    
    # Stage files
    - git add "$VALIDATED_DIR/" || true
    - git add "$FAILED_DIR/" || true
    - git add "$JSON_REPORT" || true
    - git add "$MD_REPORT" || true
    - git add "$NEW_RULES_DIR/" || true
    
    # Show what we're committing
    - echo "üìù Files to be committed:"
    - git status --short
    
    # Commit and push (exit gracefully if nothing to commit)
    - git commit -m "CI: Add validated YARA rules and reports [skip ci]" || (echo "Nothing to commit" && exit 0)
    - git push origin HEAD:${CI_COMMIT_REF_NAME}
    - echo "‚úÖ Successfully pushed to ${CI_COMMIT_REF_NAME}"
  
  allow_failure: true

# ==============================================================================
# STAGE 3: INTEGRATE TO BASELINE
# ==============================================================================
integrate_to_baseline:
  stage: integrate
  needs:
    - job: validate_yara_rules
      artifacts: true
    - job: push_to_repo
  rules:
    - if: '$CI_COMMIT_BRANCH'
      changes:
        - "$NEW_RULES_DIR/**"
      when: on_success
  image: $PYTHON_IMAGE
  <<: *python_setup
  script:
    - echo "üì¶ Integrating validated rules to baseline"
    
    # Check if we have validated rules to integrate
    - |
      if [ ! -d "$VALIDATED_DIR" ] || [ -z "$(ls -A "$VALIDATED_DIR" 2>/dev/null)" ]; then
        echo "‚ö†Ô∏è  No validated rules to integrate"
        exit 0
      fi
    
    - VALIDATED_COUNT=$(find "$VALIDATED_DIR" -type f \( -name "*.yar" -o -name "*.yara" -o -name "*.rule" \) | wc -l)
    - echo "‚úÖ Found $VALIDATED_COUNT validated rule(s) to integrate"
    
    # Step 1: Update the database with new rules
    - echo "üìä Updating database with validated rules..."
    - |
      python3 "Yara Rules/Tools/build_rule_database.py" "$VALIDATED_DIR" \
        --database "$DATABASE_PATH" \
        --verbose
    
    # Step 2: Move validated rules to baseline directory
    - echo "üìÅ Moving validated rules to baseline directory..."
    - mkdir -p "$BASELINE_DIR"
    - |
      MOVED_COUNT=0
      for file in "$VALIDATED_DIR"/*; do
        [ -f "$file" ] || continue
        
        filename=$(basename "$file")
        dest_path="$BASELINE_DIR/$filename"
        
        # Check if file already exists in baseline
        if [ -f "$dest_path" ]; then
          echo "  ‚ö†Ô∏è  File already exists in baseline: $filename (skipping)"
          continue
        fi
        
        # Move the file
        mv "$file" "$dest_path"
        echo "  ‚úÖ Moved: $filename ‚Üí Baseline_Rules/"
        MOVED_COUNT=$((MOVED_COUNT + 1))
      done
      
      echo "üìä Total rules moved to baseline: $MOVED_COUNT"
    
    # Step 3: Commit and push changes
    - echo "üì§ Committing baseline updates to repository"
    - git config --global user.email "${user_email}"
    - git config --global user.name "${user_name}"
    - git config --global http.sslcainfo "${SSL_CERT_FILE_PATH}"
    - git remote set-url origin https://alesher:${PAT_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
    
    # Pull latest changes
    - git pull origin $CI_COMMIT_REF_NAME --rebase || true
    
    # Stage changes
    - git add "$BASELINE_DIR/" || true
    - git add "$DATABASE_PATH" || true
    - git add "$VALIDATED_DIR/" || true
    
    # Show what we're committing
    - echo "üìù Files to be committed:"
    - git status --short
    
    # Commit and push
    - |
      if git diff --cached --quiet; then
        echo "‚ö†Ô∏è  No changes to commit"
        exit 0
      fi
    
    - git commit -m "CI: Integrate validated rules to baseline [skip ci]" || (echo "Nothing to commit" && exit 0)
    - git push origin HEAD:${CI_COMMIT_REF_NAME}
    - echo "‚úÖ Successfully integrated rules to baseline"
  
  allow_failure: false
